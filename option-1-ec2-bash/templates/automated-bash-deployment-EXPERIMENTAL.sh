# This is a work in progress - still working through metrics and alarms issues
#!/bin/bash
# deploy-snowball-monitor.sh
# Automated deployment script for AWS Snowball Device Monitor
# Version: 1.2 - Added explicit public IP assignment and SSH security group rules

set -o pipefail

# Script configuration
SCRIPT_VERSION="1.3"
CONFIG_FILE=".snowball-monitor.env"
STATE_FILE=".snowball-monitor-state.json"
SSH_KEY_PATH=""
DEPLOY_TIMESTAMP=$(date '+%Y%m%d-%H%M%S')

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Configuration variables (will be set by user input or config file)
SNOWBALL_IPS=""
ALERT_EMAIL=""
AWS_REGION=""
VPC_ID=""
SUBNET_ID=""
INSTANCE_TYPE="t3.nano"
MONITORING_FREQUENCY="5"
SSH_KEY_NAME=""
USER_IP=""
BASTION_SG_ID=""
SNS_TOPIC_NAME="snowball-monitor-alerts"
IAM_ROLE_NAME="SnowballMonitoringRole"
IAM_POLICY_NAME="SnowballMonitoringPolicy"
INSTANCE_PROFILE_NAME="SnowballMonitoringProfile"
EC2_INSTANCE_NAME="SnowballMonitor"

# Instance variables (to be populated)
INSTANCE_ID=""
INSTANCE_PRIVATE_IP=""
INSTANCE_PUBLIC_IP=""
SNS_TOPIC_ARN=""
SECURITY_GROUP_ID=""

# Resource tracking (for idempotency)
declare -A CREATED_RESOURCES

# ===============================================
# UTILITY FUNCTIONS
# ===============================================

log_info() {
    echo -e "${BLUE}[$(date '+%H:%M:%S')] INFO:${NC} $1"
}

log_success() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')] SUCCESS:${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] WARNING:${NC} $1"
}

log_error() {
    echo -e "${RED}[$(date '+%H:%M:%S')] ERROR:${NC} $1"
}

log_step() {
    echo -e "\n${CYAN}${BOLD}==== $1 ====${NC}"
}

prompt_user() {
    local prompt="$1"
    local default="$2"
    local result=""
    
    if [[ -n "$default" ]]; then
        read -p "$prompt [$default]: " result
        result=${result:-$default}
    else
        read -p "$prompt: " result
    fi
    
    echo "$result"
}

prompt_yes_no() {
    local prompt="$1"
    local default="$2"
    local result=""
    
    while true; do
        if [[ "$default" == "y" ]]; then
            read -p "$prompt [Y/n]: " result
            result=${result:-y}
        else
            read -p "$prompt [y/N]: " result
            result=${result:-n}
        fi
        
        case $result in
            [Yy]* ) echo "y"; break;;
            [Nn]* ) echo "n"; break;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

validate_ip() {
    local ip=$1
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        return 0
    else
        return 1
    fi
}

save_state() {
    local resource_type="$1"
    local resource_id="$2"
    CREATED_RESOURCES["$resource_type"]="$resource_id"
    
    # Save to state file (simple key=value format)
    if command -v jq &> /dev/null; then
        # Create a simple JSON object from the associative array
        local json_content="{"
        local first=true
        for key in "${!CREATED_RESOURCES[@]}"; do
            if [[ "$first" == "true" ]]; then
                first=false
            else
                json_content+=","
            fi
            json_content+="\"$key\":\"${CREATED_RESOURCES[$key]}\""
        done
        json_content+="}"
        echo "$json_content" > "$STATE_FILE"
    fi
}

# Function to count devices
count_snowball_devices() {
    if [[ -z "$SNOWBALL_IPS" ]]; then
        echo "0"
        return
    fi
    
    IFS=',' read -ra IPS <<< "$SNOWBALL_IPS"
    echo "${#IPS[@]}"
}

# Function to create complete user data script with monitoring configuration
create_complete_user_data_script() {
    local user_data_file="$1"
    
    log_info "Creating user data script with monitoring configuration..."
    
    cat > "$user_data_file" << EOF
#!/bin/bash
# Complete user data script with monitoring setup
# Generated by Snowball Monitor deployment script v$SCRIPT_VERSION

yum update -y
yum install -y nc bc aws-cli cronie cronie-anacron

# Ensure SSM agent is installed and running (for Session Manager)
yum install -y amazon-ssm-agent
systemctl enable amazon-ssm-agent
systemctl start amazon-ssm-agent

# Create monitoring user
useradd -m -s /bin/bash snowball-monitor

# Create directories
mkdir -p /opt/snowball-monitor/logs
chown -R snowball-monitor:snowball-monitor /opt/snowball-monitor

# Set up log rotation
cat > /etc/logrotate.d/snowball-monitor << 'LOGEOF'
/opt/snowball-monitor/logs/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 644 snowball-monitor snowball-monitor
}
LOGEOF

# Start and enable cron service
systemctl enable crond
systemctl start crond

# Configure timezone
timedatectl set-timezone UTC

# ===== CREATE MONITORING SCRIPT =====
cat > /opt/snowball-monitor/snowball-monitor.sh << 'MONITOREOF'
#!/bin/bash
# multi-snowball-monitor.sh - Generated by deployment script

# Configuration
SNOWBALL_DEVICES=(
$(IFS=',' read -ra IPS <<< "$SNOWBALL_IPS"; for ip in "${IPS[@]}"; do echo "    \"$(echo "$ip" | xargs)\""; done)
)

SNOWBALL_PORT="8443"
TIMEOUT="5"
SNS_TOPIC="$SNS_TOPIC_ARN"
STATE_FILE="/tmp/snowball-monitor-state.txt"

set -o pipefail

# Colors for better visibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Global variables
declare -A device_status
total_devices=\${#SNOWBALL_DEVICES[@]}
online_count=0
offline_count=0

# Logging functions
log_info() {
    echo -e "\${BLUE}[\$(date '+%Y-%m-%d %H:%M:%S')] INFO:\${NC} \$1"
}

log_success() {
    echo -e "\${GREEN}[\$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS:\${NC} \$1"
}

log_warning() {
    echo -e "\${YELLOW}[\$(date '+%Y-%m-%d %H:%M:%S')] WARNING:\${NC} \$1"
}

log_error() {
    echo -e "\${RED}[\$(date '+%Y-%m-%d %H:%M:%S')] ERROR:\${NC} \$1"
}

# Send device metric
send_device_metric() {
    local device_ip=\$1
    local metric_value=\$2
    local status_text=\$3
    
    log_info "Sending metric for device \$device_ip: Status=\$metric_value"
    
    if aws cloudwatch put-metric-data \
        --namespace "Snowball/MultiDevice" \
        --metric-data MetricName=DeviceStatus,Value=\$metric_value,Unit=Count,Dimensions=[{Name=DeviceIP,Value=\$device_ip}] 2>/dev/null; then
        log_success "Device metric sent for \$device_ip (\$status_text)"
        return 0
    else
        log_error "Failed to send device metric for \$device_ip"
        return 1
    fi
}

# Send summary metrics
send_summary_metrics() {
    log_info "Sending summary metrics: \$online_count online, \$offline_count offline"
    
    local success=true
    
    if ! aws cloudwatch put-metric-data \
        --namespace "Snowball/MultiDevice" \
        --metric-data MetricName=TotalOnline,Value=\$online_count,Unit=Count 2>/dev/null; then
        log_error "Failed to send TotalOnline metric"
        success=false
    fi
    
    if ! aws cloudwatch put-metric-data \
        --namespace "Snowball/MultiDevice" \
        --metric-data MetricName=TotalOffline,Value=\$offline_count,Unit=Count 2>/dev/null; then
        log_error "Failed to send TotalOffline metric"
        success=false
    fi
    
    if ! aws cloudwatch put-metric-data \
        --namespace "Snowball/MultiDevice" \
        --metric-data MetricName=TotalDevices,Value=\$total_devices,Unit=Count 2>/dev/null; then
        log_error "Failed to send TotalDevices metric"
        success=false
    fi
    
    if \$success; then
        log_success "Summary metrics sent successfully"
    fi
    
    return \$(\$success && echo 0 || echo 1)
}

# Get previous state
get_previous_state() {
    if [[ -f "\$STATE_FILE" ]]; then
        cat "\$STATE_FILE"
    else
        echo ""
    fi
}

# Save current state
save_current_state() {
    local offline_devices=()
    for device_ip in "\${SNOWBALL_DEVICES[@]}"; do
        if [[ \${device_status[\$device_ip]} -eq 0 ]]; then
            offline_devices+=("\$device_ip")
        fi
    done
    
    printf "%s" "\$(IFS=,; echo "\${offline_devices[*]}")" > "\$STATE_FILE"
}

# Send alert if status changed
send_alert_if_changed() {
    local current_offline=()
    for device_ip in "\${SNOWBALL_DEVICES[@]}"; do
        if [[ \${device_status[\$device_ip]} -eq 0 ]]; then
            current_offline+=("\$device_ip")
        fi
    done
    
    local current_state
    current_state=\$(IFS=,; echo "\${current_offline[*]}")
    
    local previous_state
    previous_state=\$(get_previous_state)
    
    if [[ "\$current_state" != "\$previous_state" ]]; then
        log_info "Device status changed, sending alert..."
        
        local message
        if [[ \${#current_offline[@]} -eq 0 ]]; then
            message="✅ SNOWBALL RECOVERY: All devices are now online as of \$(date '+%Y-%m-%d %H:%M:%S')"
            if [[ -n "\$previous_state" ]]; then
                message="\$message. Previously offline: \$previous_state"
            fi
        else
            message="❌ SNOWBALL ALERT: \${#current_offline[@]} of \$total_devices devices offline as of \$(date '+%Y-%m-%d %H:%M:%S')"
            message="\$message. Offline devices: \$(IFS=', '; echo "\${current_offline[*]}")"
        fi
        
        if aws sns publish --topic-arn "\$SNS_TOPIC" --message "\$message" --output text &>/dev/null; then
            log_success "Status change alert sent"
        else
            log_error "Failed to send status change alert"
        fi
        
        save_current_state
    else
        log_info "No status change detected, skipping alert"
    fi
}

# Check connectivity for a single device
check_device_connectivity() {
    local device_ip=\$1
    
    log_info "Checking connectivity to \$device_ip:\$SNOWBALL_PORT"
    
    local start_time=\$(date +%s.%N 2>/dev/null || date +%s)
    
    if timeout \$TIMEOUT nc -z -v \$device_ip \$SNOWBALL_PORT 2>&1; then
        local end_time=\$(date +%s.%N 2>/dev/null || date +%s)
        local duration=\$(echo "\$end_time - \$start_time" | bc -l 2>/dev/null || echo "N/A")
        
        log_success "✅ \$device_ip is reachable (\${duration}s)"
        device_status[\$device_ip]=1
        ((online_count++))
        return 0
    else
        local end_time=\$(date +%s.%N 2>/dev/null || date +%s)
        local duration=\$(echo "\$end_time - \$start_time" | bc -l 2>/dev/null || echo "N/A")
        
        log_error "❌ \$device_ip is UNREACHABLE (\${duration}s)"
        device_status[\$device_ip]=0
        ((offline_count++))
        return 1
    fi
}

# Main execution
main() {
    echo "================================================"
    echo "    Multi-Device Snowball Monitoring Script"
    echo "================================================"
    echo "Monitoring \${#SNOWBALL_DEVICES[@]} devices:"
    for device in "\${SNOWBALL_DEVICES[@]}"; do
        echo "  - \$device:\$SNOWBALL_PORT"
    done
    echo "Started: \$(date '+%Y-%m-%d %H:%M:%S')"
    echo "================================================"
    echo ""
    
    if [[ \${#SNOWBALL_DEVICES[@]} -eq 0 ]]; then
        log_error "No devices configured"
        exit 1
    fi
    
    # Reset counters
    online_count=0
    offline_count=0
    
    # Check each device
    for device_ip in "\${SNOWBALL_DEVICES[@]}"; do
        check_device_connectivity "\$device_ip" || true
        send_device_metric "\$device_ip" "\${device_status[\$device_ip]}" \
            "\$([ \${device_status[\$device_ip]} -eq 1 ] && echo "online" || echo "offline")" || true
    done
    
    # Send summary metrics
    send_summary_metrics || log_warning "Some summary metrics failed to send"
    
    # Handle alerting
    send_alert_if_changed || log_warning "Alert sending failed"
    
    # Show results
    echo ""
    echo "================================================"
    echo "           MONITORING SUMMARY"
    echo "================================================"
    echo "Total Devices: \$total_devices"
    echo "Online: \$online_count"
    echo "Offline: \$offline_count"
    echo ""
    
    if [[ \$offline_count -gt 0 ]]; then
        echo "❌ OFFLINE DEVICES:"
        for device_ip in "\${SNOWBALL_DEVICES[@]}"; do
            if [[ \${device_status[\$device_ip]} -eq 0 ]]; then
                echo "  - \$device_ip"
            fi
        done
        exit 1
    else
        echo "✅ ALL DEVICES ONLINE"
        exit 0
    fi
}

# Handle interruption
trap 'log_warning "Script interrupted"; exit 130' INT TERM

# Run main function
main
MONITOREOF

# Make script executable
chmod +x /opt/snowball-monitor/snowball-monitor.sh
chown snowball-monitor:snowball-monitor /opt/snowball-monitor/snowball-monitor.sh

# Create wrapper script for cron with proper logging
cat > /opt/snowball-monitor/run-monitor.sh << 'WRAPPEREOF'
#!/bin/bash
SCRIPT_DIR="/opt/snowball-monitor"
LOG_DIR="\$SCRIPT_DIR/logs"
LOG_FILE="\$LOG_DIR/monitor-\$(date +%Y%m%d).log"

# Ensure log directory exists
mkdir -p "\$LOG_DIR"

# Run the monitoring script and log output
echo "=== Monitor run started at \$(date) ===" >> "\$LOG_FILE"
cd "\$SCRIPT_DIR"
./snowball-monitor.sh >> "\$LOG_FILE" 2>&1
EXIT_CODE=\$?
echo "=== Monitor run finished at \$(date) with exit code \$EXIT_CODE ===" >> "\$LOG_FILE"
echo "" >> "\$LOG_FILE"

exit \$EXIT_CODE
WRAPPEREOF

chmod +x /opt/snowball-monitor/run-monitor.sh
chown snowball-monitor:snowball-monitor /opt/snowball-monitor/run-monitor.sh

# Set up cron job for monitoring
echo "*/$MONITORING_FREQUENCY * * * * /opt/snowball-monitor/run-monitor.sh" | sudo -u snowball-monitor crontab -

# Verify SSM agent is running
systemctl status amazon-ssm-agent --no-pager

# Signal completion
echo "Instance initialization complete"
echo "SSM Agent status: \$(systemctl is-active amazon-ssm-agent)"
echo "Monitoring setup complete - running every $MONITORING_FREQUENCY minutes" > /opt/snowball-monitor/setup-complete.txt
echo "Configured devices: $SNOWBALL_IPS" >> /opt/snowball-monitor/setup-complete.txt
echo "SNS topic: $SNS_TOPIC_ARN" >> /opt/snowball-monitor/setup-complete.txt
echo "Setup completed at: \$(date)" >> /opt/snowball-monitor/setup-complete.txt

# Run the monitoring script once to test setup
log_info "Running initial monitoring test..."
sudo -u snowball-monitor /opt/snowball-monitor/snowball-monitor.sh > /opt/snowball-monitor/logs/initial-test.log 2>&1
INITIAL_EXIT=\$?
echo "Initial monitoring test exit code: \$INITIAL_EXIT" >> /opt/snowball-monitor/setup-complete.txt
EOF
    
    log_success "User data script created with complete monitoring configuration"
}

# Function to get instance IP details
get_instance_details() {
    local instance_id="$1"
    
    log_info "Retrieving instance details for $instance_id..."
    
    # Get instance details with retries
    local attempts=0
    local max_attempts=5
    
    while [[ $attempts -lt $max_attempts ]]; do
        local instance_details=$(aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --instance-ids "$instance_id" \
            --query 'Reservations[0].Instances[0]' \
            --output json 2>/dev/null)
        
        if [[ $? -eq 0 ]] && [[ "$instance_details" != "null" ]]; then
            # Parse IP addresses
            INSTANCE_PRIVATE_IP=$(echo "$instance_details" | jq -r '.PrivateIpAddress // empty')
            INSTANCE_PUBLIC_IP=$(echo "$instance_details" | jq -r '.PublicIpAddress // empty')
            
            # Set fallback values
            [[ -z "$INSTANCE_PRIVATE_IP" ]] && INSTANCE_PRIVATE_IP="none"
            [[ -z "$INSTANCE_PUBLIC_IP" ]] && INSTANCE_PUBLIC_IP="none"
            
            log_success "Instance details retrieved:"
            echo "  Private IP: $INSTANCE_PRIVATE_IP"
            echo "  Public IP: $INSTANCE_PUBLIC_IP"
            return 0
        else
            ((attempts++))
            log_warning "Failed to get instance details (attempt $attempts/$max_attempts)"
            sleep 5
        fi
    done
    
    log_error "Could not retrieve instance details after $max_attempts attempts"
    return 1
}

# Function to detect user's current IP
detect_user_ip() {
    log_info "Auto-detecting your current public IP address..."
    
    local detected_ip=""
    local ip_services=("https://checkip.amazonaws.com" "https://ipinfo.io/ip" "https://ifconfig.me")
    
    for service in "${ip_services[@]}"; do
        detected_ip=$(curl -s --connect-timeout 10 "$service" 2>/dev/null | tr -d '\n\r ')
        if validate_ip "$detected_ip"; then
            log_success "Detected IP: $detected_ip"
            echo "$detected_ip"
            return 0
        fi
    done
    
    log_warning "Could not auto-detect IP address"
    echo ""
}

# Function to check if subnet is public
check_subnet_public() {
    local subnet_id="$1"
    
    log_info "Checking if subnet $subnet_id is public..."
    
    # Get route table for this subnet
    local route_table_id=$(aws ec2 describe-route-tables \
        --region "$AWS_REGION" \
        --filters "Name=association.subnet-id,Values=$subnet_id" \
        --query 'RouteTables[0].RouteTableId' \
        --output text 2>/dev/null)
    
    if [[ -z "$route_table_id" ]] || [[ "$route_table_id" == "None" ]]; then
        # Check for main route table
        local vpc_id=$(aws ec2 describe-subnets \
            --region "$AWS_REGION" \
            --subnet-ids "$subnet_id" \
            --query 'Subnets[0].VpcId' \
            --output text 2>/dev/null)
        
        route_table_id=$(aws ec2 describe-route-tables \
            --region "$AWS_REGION" \
            --filters "Name=vpc-id,Values=$vpc_id" "Name=association.main,Values=true" \
            --query 'RouteTables[0].RouteTableId' \
            --output text 2>/dev/null)
    fi
    
    if [[ -n "$route_table_id" ]] && [[ "$route_table_id" != "None" ]]; then
        # Check for internet gateway route
        local igw_route=$(aws ec2 describe-route-tables \
            --region "$AWS_REGION" \
            --route-table-ids "$route_table_id" \
            --query 'RouteTables[0].Routes[?GatewayId!=null && starts_with(GatewayId, `igw-`)]' \
            --output text 2>/dev/null)
        
        if [[ -n "$igw_route" ]]; then
            log_success "Subnet is public (has internet gateway route)"
            return 0
        else
            log_warning "Subnet appears to be private (no internet gateway route found)"
            return 1
        fi
    else
        log_warning "Could not determine subnet routing"
        return 1
    fi
}

# ===============================================
# PREREQUISITE CHECKS
# ===============================================

check_prerequisites() {
    log_step "Checking Prerequisites"
    
    # Check if running on compatible OS
    if [[ "$OSTYPE" != "linux-gnu"* ]] && [[ "$OSTYPE" != "darwin"* ]]; then
        log_warning "This script is designed for Linux/macOS. Windows users should use WSL."
    fi
    
    # Check required commands
    local required_commands=("aws" "jq" "ssh" "nc" "curl")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_error "Missing required commands: ${missing_commands[*]}"
        echo ""
        echo "Please install the missing commands:"
        for cmd in "${missing_commands[@]}"; do
            case $cmd in
                "aws") echo "  - AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html";;
                "jq") echo "  - jq: https://stedolan.github.io/jq/download/";;
                "ssh") echo "  - ssh: Usually pre-installed on Linux/macOS";;
                "nc") echo "  - netcat: Usually pre-installed on Linux/macOS";;
                "curl") echo "  - curl: Usually pre-installed on Linux/macOS";;
            esac
        done
        exit 1
    fi
    
    # Check AWS CLI configuration
    log_info "Checking AWS CLI configuration..."
    if ! aws sts get-caller-identity &> /dev/null; then
        log_error "AWS CLI is not configured or credentials are invalid."
        echo ""
        echo "Please configure AWS CLI first:"
        echo "  aws configure"
        echo ""
        echo "Or set environment variables:"
        echo "  export AWS_ACCESS_KEY_ID=your_access_key"
        echo "  export AWS_SECRET_ACCESS_KEY=your_secret_key"
        echo "  export AWS_DEFAULT_REGION=your_region"
        exit 1
    fi
    
    # Get AWS account info
    local aws_account=$(aws sts get-caller-identity --query Account --output text 2>/dev/null)
    local aws_user=$(aws sts get-caller-identity --query Arn --output text 2>/dev/null)
    AWS_REGION=$(aws configure get region 2>/dev/null || echo "us-east-1")
    
    log_success "AWS CLI configured"
    echo "  Account: $aws_account"
    echo "  User/Role: $aws_user"
    echo "  Region: $AWS_REGION"
    
    # Check basic permissions
    log_info "Checking AWS permissions..."
    local permissions_ok=true
    
    # Test IAM permissions
    if ! aws iam list-roles --max-items 1 &> /dev/null; then
        log_warning "Limited IAM permissions detected"
        permissions_ok=false
    fi
    
    # Test EC2 permissions
    if ! aws ec2 describe-vpcs --max-items 1 &> /dev/null; then
        log_warning "Limited EC2 permissions detected"
        permissions_ok=false
    fi
    
    if [[ "$permissions_ok" == "false" ]]; then
        log_warning "Some AWS permissions may be missing. Deployment might fail."
        if [[ $(prompt_yes_no "Continue anyway?") == "n" ]]; then
            exit 1
        fi
    else
        log_success "AWS permissions look good"
    fi
}

# ===============================================
# CONFIGURATION MANAGEMENT
# ===============================================

load_existing_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Loading existing configuration from $CONFIG_FILE"
        source "$CONFIG_FILE"
        return 0
    else
        return 1
    fi
}

save_config() {
    log_info "Saving configuration to $CONFIG_FILE"
    cat > "$CONFIG_FILE" << EOF
# Snowball Monitor Configuration
# Generated on $(date)

SNOWBALL_IPS="$SNOWBALL_IPS"
ALERT_EMAIL="$ALERT_EMAIL"
AWS_REGION="$AWS_REGION"
VPC_ID="$VPC_ID"
SUBNET_ID="$SUBNET_ID"
INSTANCE_TYPE="$INSTANCE_TYPE"
MONITORING_FREQUENCY="$MONITORING_FREQUENCY"
SSH_KEY_NAME="$SSH_KEY_NAME"
USER_IP="$USER_IP"
BASTION_SG_ID="$BASTION_SG_ID"
SNS_TOPIC_NAME="$SNS_TOPIC_NAME"
IAM_ROLE_NAME="$IAM_ROLE_NAME"
IAM_POLICY_NAME="$IAM_POLICY_NAME"
INSTANCE_PROFILE_NAME="$INSTANCE_PROFILE_NAME"
EC2_INSTANCE_NAME="$EC2_INSTANCE_NAME"
DEPLOY_TIMESTAMP="$DEPLOY_TIMESTAMP"
EOF
    log_success "Configuration saved"
}

configure_deployment() {
    log_step "Configuration Setup"
    
    # Load existing config if available
    local has_existing_config=false
    if load_existing_config; then
        has_existing_config=true
        echo "Found existing configuration:"
        echo "  Snowball IPs: $SNOWBALL_IPS"
        echo "  Alert Email: $ALERT_EMAIL"
        echo "  AWS Region: $AWS_REGION"
        echo "  VPC: $VPC_ID"
        echo "  Subnet: $SUBNET_ID"
        echo "  User IP: $USER_IP"
        echo "  Bastion SG: ${BASTION_SG_ID:-"None"}"
        echo ""
        
        if [[ $(prompt_yes_no "Use existing configuration?") == "y" ]]; then
            log_success "Using existing configuration"
            return 0
        fi
    fi
    
    # Get Snowball device IPs
    echo ""
    echo "Enter the IP addresses of your Snowball devices."
    echo "You can enter multiple IPs separated by commas (e.g., 10.0.1.100,10.0.1.101)"
    while true; do
        SNOWBALL_IPS=$(prompt_user "Snowball Device IPs" "$SNOWBALL_IPS")
        
        # Validate IPs
        IFS=',' read -ra IPS <<< "$SNOWBALL_IPS"
        local valid=true
        for ip in "${IPS[@]}"; do
            ip=$(echo "$ip" | xargs) # trim whitespace
            if ! validate_ip "$ip"; then
                log_error "Invalid IP address: $ip"
                valid=false
            fi
        done
        
        if [[ "$valid" == "true" ]]; then
            log_success "Valid IP addresses: $SNOWBALL_IPS"
            break
        fi
    done
    
    # Get alert email
    echo ""
    while true; do
        ALERT_EMAIL=$(prompt_user "Email for alerts" "$ALERT_EMAIL")
        if [[ "$ALERT_EMAIL" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
            break
        else
            log_error "Invalid email format"
        fi
    done
    
    # AWS Region confirmation
    echo ""
    local new_region=$(prompt_user "AWS Region" "$AWS_REGION")
    if [[ "$new_region" != "$AWS_REGION" ]]; then
        AWS_REGION="$new_region"
        log_info "Region changed to $AWS_REGION"
    fi
    
    # VPC Selection
    select_vpc
    
    # Subnet Selection
    select_subnet
    
    # SSH Configuration
    configure_ssh_access
    
    # Instance type
    echo ""
    echo "Available instance types:"
    echo "  1) t3.nano  (~$3.50/month) - Minimal resources"
    echo "  2) t3.micro (~$7.00/month) - Recommended"
    echo "  3) t3.small (~$14.00/month) - Extra headroom"
    local instance_choice=$(prompt_user "Select instance type [1-3]" "2")
    case $instance_choice in
        1) INSTANCE_TYPE="t3.nano";;
        2) INSTANCE_TYPE="t3.micro";;
        3) INSTANCE_TYPE="t3.small";;
        *) INSTANCE_TYPE="t3.micro";;
    esac
    
    # Monitoring frequency
    echo ""
    echo "Monitoring frequency:"
    echo "  1) Every 1 minute  (more responsive)"
    echo "  2) Every 2 minutes (balanced)"
    echo "  3) Every 5 minutes (less frequent)"
    local freq_choice=$(prompt_user "Select frequency [1-3]" "3")
    case $freq_choice in
        1) MONITORING_FREQUENCY="1";;
        2) MONITORING_FREQUENCY="2";;
        3) MONITORING_FREQUENCY="5";;
        *) MONITORING_FREQUENCY="5";;
    esac
    
    # Save configuration
    save_config
    
    echo ""
    log_success "Configuration complete!"
}

select_vpc() {
    echo ""
    log_info "Fetching available VPCs..."
    
    local vpcs=$(aws ec2 describe-vpcs --region "$AWS_REGION" --output json 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        log_error "Failed to fetch VPCs"
        exit 1
    fi
    
    local vpc_count=$(echo "$vpcs" | jq '.Vpcs | length')
    if [[ $vpc_count -eq 0 ]]; then
        log_error "No VPCs found in region $AWS_REGION"
        exit 1
    fi
    
    echo ""
    echo "Available VPCs in $AWS_REGION:"
    
    local vpc_ids=()
    for i in $(seq 0 $((vpc_count-1))); do
        local vpc_id=$(echo "$vpcs" | jq -r ".Vpcs[$i].VpcId")
        local cidr=$(echo "$vpcs" | jq -r ".Vpcs[$i].CidrBlock")
        local is_default=$(echo "$vpcs" | jq -r ".Vpcs[$i].IsDefault")
        local name_tag=$(echo "$vpcs" | jq -r ".Vpcs[$i].Tags[]? | select(.Key==\"Name\") | .Value" 2>/dev/null || echo "")
        
        vpc_ids+=("$vpc_id")
        
        local display_name="$vpc_id"
        if [[ -n "$name_tag" ]]; then
            display_name="$display_name ($name_tag)"
        fi
        if [[ "$is_default" == "true" ]]; then
            display_name="$display_name [default]"
        fi
        
        echo "  $((i+1))) $display_name - $cidr"
    done
    
    while true; do
        local choice=$(prompt_user "Select VPC [1-$vpc_count]" "1")
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $vpc_count ]]; then
            VPC_ID="${vpc_ids[$((choice-1))]}"
            log_success "Selected VPC: $VPC_ID"
            break
        else
            log_error "Invalid choice. Please enter a number between 1 and $vpc_count"
        fi
    done
}

select_subnet() {
    echo ""
    log_info "Fetching available subnets in $VPC_ID..."
    
    local subnets=$(aws ec2 describe-subnets --region "$AWS_REGION" --filters "Name=vpc-id,Values=$VPC_ID" --output json 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        log_error "Failed to fetch subnets"
        exit 1
    fi
    
    local subnet_count=$(echo "$subnets" | jq '.Subnets | length')
    if [[ $subnet_count -eq 0 ]]; then
        log_error "No subnets found in VPC $VPC_ID"
        exit 1
    fi
    
    echo ""
    echo "Available subnets in $VPC_ID:"
    
    local subnet_ids=()
    for i in $(seq 0 $((subnet_count-1))); do
        local subnet_id=$(echo "$subnets" | jq -r ".Subnets[$i].SubnetId")
        local cidr=$(echo "$subnets" | jq -r ".Subnets[$i].CidrBlock")
        local az=$(echo "$subnets" | jq -r ".Subnets[$i].AvailabilityZone")
        local name_tag=$(echo "$subnets" | jq -r ".Subnets[$i].Tags[]? | select(.Key==\"Name\") | .Value" 2>/dev/null || echo "")
        
        subnet_ids+=("$subnet_id")
        
        local display_name="$subnet_id"
        if [[ -n "$name_tag" ]]; then
            display_name="$display_name ($name_tag)"
        fi
        
        echo "  $((i+1))) $display_name - $cidr (AZ: $az)"
    done
    
    while true; do
        local choice=$(prompt_user "Select subnet [1-$subnet_count]" "1")
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $subnet_count ]]; then
            SUBNET_ID="${subnet_ids[$((choice-1))]}"
            log_success "Selected subnet: $SUBNET_ID"
            
            # Check if subnet is public
            if ! check_subnet_public "$SUBNET_ID"; then
                echo ""
                log_warning "⚠️  PRIVATE SUBNET DETECTED"
                echo ""
                echo "This subnet appears to be private (no internet gateway route), but the instance"
                echo "will still be assigned a public IP address. This means:"
                echo ""
                echo "  ✅ The instance will be able to reach AWS services"
                echo "  ⚠️  The instance may not be able to route to the internet properly"
                echo "  ⚠️  For proper private subnet deployment, see the Advanced Networking Guide"
                echo ""
                echo "Advanced Networking Guide: https://github.com/your-repo/Advanced-Networking-Guide.md"
                echo ""
                
                if [[ $(prompt_yes_no "Are you sure you want to continue with this subnet?") == "n" ]]; then
                    continue
                fi
            fi
            break
        else
            log_error "Invalid choice. Please enter a number between 1 and $subnet_count"
        fi
    done
}

configure_ssh_access() {
    echo ""
    log_step "SSH Access Configuration"
    
    echo "The instance will be assigned a public IP address and can be accessed via:"
    echo "  • AWS Systems Manager Session Manager (browser-based, no SSH key needed)"
    echo "  • SSH (requires SSH key pair and proper security group rules)"
    echo ""
    
    # SSH Key Selection
    select_ssh_key
    
    # Get user's IP for SSH security group rule
    if [[ -n "$SSH_KEY_NAME" ]]; then
        echo ""
        log_info "SSH Security Group Configuration"
        echo "To enable SSH access, we need to add your IP address to the security group."
        echo ""
        
        # Auto-detect user IP
        local detected_ip=$(detect_user_ip)
        if [[ -n "$detected_ip" ]]; then
            USER_IP=$(prompt_user "Your IP address for SSH access" "$detected_ip")
        else
            USER_IP=$(prompt_user "Your IP address for SSH access" "$USER_IP")
        fi
        
        # Validate user IP
        while ! validate_ip "$USER_IP"; do
            log_error "Invalid IP address format"
            USER_IP=$(prompt_user "Your IP address for SSH access")
        done
        
        log_success "Will allow SSH from: $USER_IP/32"
        
        # Ask about bastion host
        echo ""
        if [[ $(prompt_yes_no "Do you have a bastion host that needs SSH access to this instance?") == "y" ]]; then
            echo ""
            log_info "Fetching security groups for bastion host selection..."
            
            local sgs=$(aws ec2 describe-security-groups --region "$AWS_REGION" --filters "Name=vpc-id,Values=$VPC_ID" --output json 2>/dev/null)
            local sg_count=$(echo "$sgs" | jq '.SecurityGroups | length')
            
            if [[ $sg_count -gt 0 ]]; then
                echo ""
                echo "Available security groups (look for your bastion host security group):"
                
                local sg_ids=()
                for i in $(seq 0 $((sg_count-1))); do
                    local sg_id=$(echo "$sgs" | jq -r ".SecurityGroups[$i].GroupId")
                    local sg_name=$(echo "$sgs" | jq -r ".SecurityGroups[$i].GroupName")
                    local sg_desc=$(echo "$sgs" | jq -r ".SecurityGroups[$i].Description")
                    
                    sg_ids+=("$sg_id")
                    echo "  $((i+1))) $sg_id - $sg_name ($sg_desc)"
                done
                
                echo "  0) Skip bastion host configuration"
                
                while true; do
                    local choice=$(prompt_user "Select bastion security group [0-$sg_count]" "0")
                    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 0 ]] && [[ $choice -le $sg_count ]]; then
                        if [[ $choice -eq 0 ]]; then
                            log_info "Skipping bastion host configuration"
                            break
                        else
                            BASTION_SG_ID="${sg_ids[$((choice-1))]}"
                            log_success "Selected bastion security group: $BASTION_SG_ID"
                            break
                        fi
                    else
                        log_error "Invalid choice. Please enter a number between 0 and $sg_count"
                    fi
                done
            else
                log_warning "No security groups found in VPC"
            fi
        fi
    else
        log_info "No SSH key configured - access will be via Session Manager only"
    fi
}

select_ssh_key() {
    log_info "SSH Key Selection (Optional but Recommended)"
    echo "You can configure an SSH key for direct SSH access to the instance."
    echo "If you skip this, you can still use AWS Systems Manager Session Manager."
    echo ""
    
    log_info "Fetching available SSH key pairs..."
    
    local keys=$(aws ec2 describe-key-pairs --region "$AWS_REGION" --output json 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        log_warning "Failed to fetch SSH key pairs"
        return
    fi
    
    local key_count=$(echo "$keys" | jq '.KeyPairs | length')
    if [[ $key_count -eq 0 ]]; then
        log_info "No SSH key pairs found in region $AWS_REGION"
        echo "Continuing without SSH key - Session Manager will be available for access."
        return
    fi
    
    echo ""
    echo "Available SSH key pairs:"
    echo "  0) Continue without SSH key (Session Manager only)"
    
    local key_names=()
    for i in $(seq 0 $((key_count-1))); do
        local key_name=$(echo "$keys" | jq -r ".KeyPairs[$i].KeyName")
        key_names+=("$key_name")
        echo "  $((i+1))) $key_name"
    done
    
    while true; do
        local choice=$(prompt_user "Select SSH key [0-$key_count]" "0")
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 0 ]] && [[ $choice -le $key_count ]]; then
            if [[ $choice -eq 0 ]]; then
                SSH_KEY_NAME=""
                log_info "Continuing without SSH key - Session Manager will be available"
            else
                SSH_KEY_NAME="${key_names[$((choice-1))]}"
                log_success "Selected SSH key: $SSH_KEY_NAME"
                
                # Ask for local SSH key path
                echo ""
                echo "Enter the path to your local SSH private key file for $SSH_KEY_NAME"
                echo "(This is optional - only needed if you want to test SSH connectivity)"
                SSH_KEY_PATH=$(prompt_user "SSH key path" "$HOME/.ssh/$SSH_KEY_NAME.pem")
                
                if [[ ! -f "$SSH_KEY_PATH" ]]; then
                    log_warning "SSH key file not found at $SSH_KEY_PATH"
                    log_info "You can still use the key name for SSH access"
                fi
            fi
            break
        else
            log_error "Invalid choice. Please enter a number between 0 and $key_count"
        fi
    done
}

# ===============================================
# INFRASTRUCTURE DEPLOYMENT
# ===============================================

deploy_infrastructure() {
    log_step "Deploying Infrastructure"
    
    create_sns_topic
    create_iam_resources
    create_security_group
    launch_ec2_instance
    create_cloudwatch_alarms
}

create_sns_topic() {
    log_info "Creating SNS topic for alerts..."
    
    # Check if topic already exists
    local existing_topic=$(aws sns list-topics --region "$AWS_REGION" --output text --query "Topics[?contains(@, '$SNS_TOPIC_NAME')].TopicArn" 2>/dev/null | head -1)
    
    if [[ -n "$existing_topic" ]]; then
        log_success "SNS topic already exists: $existing_topic"
        SNS_TOPIC_ARN="$existing_topic"
    else
        local topic_arn=$(aws sns create-topic --name "$SNS_TOPIC_NAME" --region "$AWS_REGION" --query TopicArn --output text 2>/dev/null)
        if [[ $? -eq 0 ]] && [[ -n "$topic_arn" ]]; then
            log_success "Created SNS topic: $topic_arn"
            SNS_TOPIC_ARN="$topic_arn"
            save_state "sns_topic" "$topic_arn"
        else
            log_error "Failed to create SNS topic"
            exit 1
        fi
    fi
    
    # Subscribe email to topic
    log_info "Subscribing $ALERT_EMAIL to SNS topic..."
    local subscription_arn=$(aws sns subscribe --topic-arn "$SNS_TOPIC_ARN" --protocol email --notification-endpoint "$ALERT_EMAIL" --region "$AWS_REGION" --query SubscriptionArn --output text 2>/dev/null)
    
    if [[ $? -eq 0 ]]; then
        log_success "Email subscription created (check your inbox for confirmation)"
        log_warning "IMPORTANT: Check your email and confirm the SNS subscription"
    else
        log_warning "Failed to create email subscription (you can add it manually later)"
    fi
}

create_iam_resources() {
    log_info "Creating IAM resources..."
    
    # Create IAM policy
    local policy_arn=""
    local existing_policy=$(aws iam list-policies --query "Policies[?PolicyName=='$IAM_POLICY_NAME'].Arn" --output text 2>/dev/null)
    
    if [[ -n "$existing_policy" ]]; then
        log_success "IAM policy already exists: $existing_policy"
        policy_arn="$existing_policy"
    else
        log_info "Creating IAM policy..."
        
        # Create policy document
        local policy_doc=$(cat << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "CloudWatchMetrics",
            "Effect": "Allow",
            "Action": [
                "cloudwatch:PutMetricData"
            ],
            "Resource": "*"
        },
        {
            "Sid": "SNSPublish", 
            "Effect": "Allow",
            "Action": [
                "sns:Publish"
            ],
            "Resource": "$SNS_TOPIC_ARN"
        },
        {
            "Sid": "GetCallerIdentity",
            "Effect": "Allow",
            "Action": [
                "sts:GetCallerIdentity"
            ],
            "Resource": "*"
        },
        {
            "Sid": "SSMSessionManager",
            "Effect": "Allow",
            "Action": [
                "ssm:UpdateInstanceInformation",
                "ssmmessages:CreateControlChannel",
                "ssmmessages:CreateDataChannel",
                "ssmmessages:OpenControlChannel",
                "ssmmessages:OpenDataChannel"
            ],
            "Resource": "*"
        },
        {
            "Sid": "SSMGetParameters",
            "Effect": "Allow",
            "Action": [
                "ssm:GetDeployablePatchSnapshotForInstance",
                "ssm:GetDocument",
                "ssm:DescribeDocument",
                "ssm:GetManifest",
                "ssm:GetParameter",
                "ssm:GetParameters",
                "ssm:ListAssociations",
                "ssm:ListInstanceAssociations",
                "ssm:PutInventory",
                "ssm:PutComplianceItems",
                "ssm:PutConfigurePackageResult",
                "ssm:UpdateAssociationStatus",
                "ssm:UpdateInstanceAssociationStatus",
                "ssm:UpdateInstanceInformation"
            ],
            "Resource": "*"
        },
        {
            "Sid": "EC2MessagesForSessionManager",
            "Effect": "Allow",
            "Action": [
                "ec2messages:AcknowledgeMessage",
                "ec2messages:DeleteMessage",
                "ec2messages:FailMessage",
                "ec2messages:GetEndpoint",
                "ec2messages:GetMessages",
                "ec2messages:SendReply"
            ],
            "Resource": "*"
        }
    ]
}
EOF
)
        
        policy_arn=$(aws iam create-policy --policy-name "$IAM_POLICY_NAME" --policy-document "$policy_doc" --query Policy.Arn --output text 2>/dev/null)
        if [[ $? -eq 0 ]] && [[ -n "$policy_arn" ]]; then
            log_success "Created IAM policy: $policy_arn"
            save_state "iam_policy" "$policy_arn"
        else
            log_error "Failed to create IAM policy"
            exit 1
        fi
    fi
    
    # Create IAM role
    local existing_role=$(aws iam get-role --role-name "$IAM_ROLE_NAME" --query Role.Arn --output text 2>/dev/null)
    
    if [[ -n "$existing_role" ]]; then
        log_success "IAM role already exists: $existing_role"
    else
        log_info "Creating IAM role..."
        
        local assume_role_doc=$(cat << 'EOF'
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "ec2.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
EOF
)
        
        local role_arn=$(aws iam create-role --role-name "$IAM_ROLE_NAME" --assume-role-policy-document "$assume_role_doc" --query Role.Arn --output text 2>/dev/null)
        if [[ $? -eq 0 ]] && [[ -n "$role_arn" ]]; then
            log_success "Created IAM role: $role_arn"
            save_state "iam_role" "$role_arn"
        else
            log_error "Failed to create IAM role"
            exit 1
        fi
    fi
    
    # Attach policy to role
    if aws iam attach-role-policy --role-name "$IAM_ROLE_NAME" --policy-arn "$policy_arn" 2>/dev/null; then
        log_success "Attached policy to role"
    else
        log_warning "Policy may already be attached to role"
    fi
    
    # Create instance profile
    local existing_profile=$(aws iam get-instance-profile --instance-profile-name "$INSTANCE_PROFILE_NAME" --query InstanceProfile.Arn --output text 2>/dev/null)
    
    if [[ -n "$existing_profile" ]]; then
        log_success "Instance profile already exists: $existing_profile"
    else
        log_info "Creating instance profile..."
        
        local profile_arn=$(aws iam create-instance-profile --instance-profile-name "$INSTANCE_PROFILE_NAME" --query InstanceProfile.Arn --output text 2>/dev/null)
        if [[ $? -eq 0 ]] && [[ -n "$profile_arn" ]]; then
            log_success "Created instance profile: $profile_arn"
            save_state "instance_profile" "$profile_arn"
        else
            log_error "Failed to create instance profile"
            exit 1
        fi
    fi
    
    # Add role to instance profile
    if aws iam add-role-to-instance-profile --instance-profile-name "$INSTANCE_PROFILE_NAME" --role-name "$IAM_ROLE_NAME" 2>/dev/null; then
        log_success "Added role to instance profile"
    else
        log_warning "Role may already be in instance profile"
    fi
    
    # Wait a moment for IAM propagation
    log_info "Waiting for IAM resources to propagate..."
    sleep 15
}

create_security_group() {
    log_info "Creating security group..."
    
    local sg_name="snowball-monitor-sg"
    local existing_sg=$(aws ec2 describe-security-groups --region "$AWS_REGION" --filters "Name=group-name,Values=$sg_name" "Name=vpc-id,Values=$VPC_ID" --query SecurityGroups[0].GroupId --output text 2>/dev/null)
    
    if [[ -n "$existing_sg" ]] && [[ "$existing_sg" != "None" ]]; then
        log_success "Security group already exists: $existing_sg"
        SECURITY_GROUP_ID="$existing_sg"
    else
        log_info "Creating new security group..."
        
        SECURITY_GROUP_ID=$(aws ec2 create-security-group --group-name "$sg_name" --description "Snowball Monitor Security Group" --vpc-id "$VPC_ID" --region "$AWS_REGION" --query GroupId --output text 2>/dev/null)
        
        if [[ $? -eq 0 ]] && [[ -n "$SECURITY_GROUP_ID" ]]; then
            log_success "Created security group: $SECURITY_GROUP_ID"
            save_state "security_group" "$SECURITY_GROUP_ID"
            
            # Add tags
            aws ec2 create-tags --resources "$SECURITY_GROUP_ID" --tags Key=Name,Value="$sg_name" Key=Purpose,Value=SnowballMonitor --region "$AWS_REGION" &>/dev/null
        else
            log_error "Failed to create security group"
            exit 1
        fi
    fi
    
    # Add SSH rules if SSH key is configured
    if [[ -n "$SSH_KEY_NAME" ]] && [[ -n "$USER_IP" ]]; then
        log_info "Adding SSH security group rules..."
        
        # Add user IP rule
        log_info "Adding SSH access from your IP: $USER_IP/32"
        if aws ec2 authorize-security-group-ingress \
            --group-id "$SECURITY_GROUP_ID" \
            --protocol tcp \
            --port 22 \
            --cidr "$USER_IP/32" \
            --region "$AWS_REGION" 2>/dev/null; then
            log_success "Added SSH rule for your IP"
        else
            log_warning "SSH rule for your IP may already exist"
        fi
        
        # Add bastion SG rule if configured
        if [[ -n "$BASTION_SG_ID" ]]; then
            log_info "Adding SSH access from bastion security group: $BASTION_SG_ID"
            if aws ec2 authorize-security-group-ingress \
                --group-id "$SECURITY_GROUP_ID" \
                --protocol tcp \
                --port 22 \
                --source-group "$BASTION_SG_ID" \
                --region "$AWS_REGION" 2>/dev/null; then
                log_success "Added SSH rule for bastion security group"
            else
                log_warning "SSH rule for bastion security group may already exist"
            fi
        fi
    else
        log_info "No SSH rules added - Session Manager access only"
    fi
}

launch_ec2_instance() {
    log_info "Launching EC2 instance with public IP..."
    
    # Check if instance already exists
    local existing_instance=$(aws ec2 describe-instances --region "$AWS_REGION" --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME" "Name=instance-state-name,Values=running,pending,stopped" --query Reservations[0].Instances[0].InstanceId --output text 2>/dev/null)
    
    if [[ -n "$existing_instance" ]] && [[ "$existing_instance" != "None" ]]; then
        log_success "EC2 instance already exists: $existing_instance"
        INSTANCE_ID="$existing_instance"
        
        # Get instance state
        local instance_state=$(aws ec2 describe-instances --region "$AWS_REGION" --instance-ids "$INSTANCE_ID" --query Reservations[0].Instances[0].State.Name --output text 2>/dev/null)
        log_info "Instance state: $instance_state"
        
        if [[ "$instance_state" == "stopped" ]]; then
            log_info "Starting stopped instance..."
            aws ec2 start-instances --instance-ids "$INSTANCE_ID" --region "$AWS_REGION" &>/dev/null
        fi
    else
        # Get latest Amazon Linux 2023 AMI
        log_info "Finding latest Amazon Linux 2023 AMI..."
        local ami_id=$(aws ec2 describe-images --region "$AWS_REGION" --owners amazon --filters "Name=name,Values=al2023-ami-*" "Name=state,Values=available" --query 'Images|sort_by(@, &CreationDate)[-1].ImageId' --output text 2>/dev/null)
        
        if [[ -z "$ami_id" ]] || [[ "$ami_id" == "None" ]]; then
            log_error "Failed to find Amazon Linux 2023 AMI"
            exit 1
        fi
        
        log_info "Using AMI: $ami_id"
        
        # Create user data script with actual monitoring configuration
        local user_data_file="/tmp/user-data-$.sh"
        create_complete_user_data_script "$user_data_file"
        
        # Build launch arguments - ALWAYS include public IP assignment
        local launch_args=(
            --region "$AWS_REGION"
            --image-id "$ami_id"
            --instance-type "$INSTANCE_TYPE"
            --security-group-ids "$SECURITY_GROUP_ID"
            --subnet-id "$SUBNET_ID"
            --iam-instance-profile "Name=$INSTANCE_PROFILE_NAME"
            --associate-public-ip-address
            --user-data "file://$user_data_file"
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$EC2_INSTANCE_NAME},{Key=Purpose,Value=SnowballMonitor}]"
        )
        
        # Add SSH key if configured
        if [[ -n "$SSH_KEY_NAME" ]]; then
            launch_args+=(--key-name "$SSH_KEY_NAME")
        fi
        
        log_info "Launching instance with public IP..."
        
        # Capture both stdout and stderr for better error reporting
        local launch_output
        launch_output=$(aws ec2 run-instances "${launch_args[@]}" --query Instances[0].InstanceId --output text 2>&1)
        local launch_exit_code=$?
        
        # Clean up temporary user data file
        rm -f "$user_data_file"
        
        if [[ $launch_exit_code -eq 0 ]] && [[ -n "$launch_output" ]] && [[ "$launch_output" != "None" ]]; then
            INSTANCE_ID="$launch_output"
            log_success "Launched EC2 instance with public IP: $INSTANCE_ID"
            save_state "ec2_instance" "$INSTANCE_ID"
        else
            log_error "Failed to launch EC2 instance"
            echo "Error details: $launch_output"
            echo ""
            echo "Common causes:"
            echo "  - Insufficient IAM permissions for EC2"
            echo "  - Instance type not available in the selected AZ"
            echo "  - Subnet has no available IP addresses"
            echo "  - Security group or VPC issues"
            echo "  - IAM instance profile not ready (try waiting a few minutes)"
            exit 1
        fi
    fi
    
    # Wait for instance to be running
    log_info "Waiting for instance to be in running state..."
    aws ec2 wait instance-running --instance-ids "$INSTANCE_ID" --region "$AWS_REGION"
    
    if [[ $? -eq 0 ]]; then
        log_success "Instance is running"
        
        # Get instance details with retries
        if get_instance_details "$INSTANCE_ID"; then
            log_info "Instance details:"
            echo "  Instance ID: $INSTANCE_ID"
            echo "  Private IP: $INSTANCE_PRIVATE_IP"
            echo "  Public IP: $INSTANCE_PUBLIC_IP"
            
            if [[ "$INSTANCE_PUBLIC_IP" == "none" ]]; then
                log_warning "No public IP assigned - this may indicate a configuration issue"
            fi
        else
            log_warning "Could not retrieve instance IP addresses"
        fi
    else
        log_error "Instance failed to reach running state"
        exit 1
    fi
    
    # Wait a bit more for user data script to complete
    log_info "Waiting for user data script to complete setup..."
    log_info "(User data script installs packages, configures monitoring, and sets up cron job)"
    sleep 180  # Give 3 minutes for the user data script to complete
}

create_cloudwatch_alarms() {
    log_info "Creating CloudWatch alarms..."
    
    local account_id=$(aws sts get-caller-identity --query Account --output text)
    
    # Alarm 1: Any device offline
    local alarm1_name="Snowball-MultiDevice-AnyOffline"
    if aws cloudwatch describe-alarms --region "$AWS_REGION" --alarm-names "$alarm1_name" &>/dev/null; then
        log_success "Alarm already exists: $alarm1_name"
    else
        aws cloudwatch put-metric-alarm \
            --region "$AWS_REGION" \
            --alarm-name "$alarm1_name" \
            --alarm-description "Alert when any Snowball device goes offline" \
            --metric-name TotalOffline \
            --namespace Snowball/MultiDevice \
            --statistic Maximum \
            --period 300 \
            --evaluation-periods 1 \
            --datapoints-to-alarm 1 \
            --threshold 0.5 \
            --comparison-operator GreaterThanThreshold \
            --alarm-actions "$SNS_TOPIC_ARN" \
            --ok-actions "$SNS_TOPIC_ARN" \
            --treat-missing-data breaching &>/dev/null
        
        if [[ $? -eq 0 ]]; then
            log_success "Created alarm: $alarm1_name"
        else
            log_warning "Failed to create alarm: $alarm1_name"
        fi
    fi
    
    # Alarm 2: Monitor not reporting
    local alarm2_name="Snowball-MultiDevice-Monitor-NotReporting"
    if aws cloudwatch describe-alarms --region "$AWS_REGION" --alarm-names "$alarm2_name" &>/dev/null; then
        log_success "Alarm already exists: $alarm2_name"
    else
        aws cloudwatch put-metric-alarm \
            --region "$AWS_REGION" \
            --alarm-name "$alarm2_name" \
            --alarm-description "Alert when monitoring script stops reporting" \
            --metric-name TotalDevices \
            --namespace Snowball/MultiDevice \
            --statistic SampleCount \
            --period 900 \
            --evaluation-periods 2 \
            --threshold 1 \
            --comparison-operator LessThanThreshold \
            --treat-missing-data breaching \
            --alarm-actions "$SNS_TOPIC_ARN" &>/dev/null
        
        if [[ $? -eq 0 ]]; then
            log_success "Created alarm: $alarm2_name"
        else
            log_warning "Failed to create alarm: $alarm2_name"
        fi
    fi
}

# ===============================================
# SCRIPT DEPLOYMENT
# ===============================================

deploy_monitoring_script() {
    log_step "Monitoring Script Setup"
    
    log_info "All monitoring configuration has been embedded in the instance user data"
    log_info "The instance will automatically configure itself during boot..."
    
    # Wait for the instance to complete setup
    log_info "Waiting for instance to complete setup (this may take 2-3 minutes)..."
    sleep 120  # Give the instance time to run user data script
    
    # Check if we can verify setup completion via Session Manager
    log_info "Instance setup should be complete"
    log_info "You can verify the setup using either Session Manager or SSH:"
    echo ""
    echo "Session Manager Access:"
    echo "1. Go to: https://console.aws.amazon.com/systems-manager/session-manager/start-session?region=$AWS_REGION"
    echo "2. Select instance: $INSTANCE_ID"
    echo ""
    
    if [[ -n "$SSH_KEY_NAME" ]] && [[ "$INSTANCE_PUBLIC_IP" != "none" ]]; then
        echo "SSH Access:"
        echo "ssh -i $SSH_KEY_PATH ec2-user@$INSTANCE_PUBLIC_IP"
        echo ""
    fi
    
    echo "Verification commands (run after connecting):"
    echo "   sudo cat /var/log/user-data.log                    # View setup log"
    echo "   sudo -u snowball-monitor crontab -l               # Check cron job"
    echo "   sudo tail -f /opt/snowball-monitor/logs/monitor-\$(date +%Y%m%d).log  # View monitoring logs"
    echo "   sudo -u snowball-monitor /opt/snowball-monitor/snowball-monitor.sh    # Test script manually"
    echo ""
    
    log_success "Monitoring script deployment initiated via user data"
    log_info "The instance will start monitoring automatically within $MONITORING_FREQUENCY minutes"
    
    return 0
}

validate_deployment() {
    log_step "Validating Deployment"
    
    # Test Snowball connectivity from deployment machine
    log_info "Testing Snowball connectivity from this machine..."
    IFS=',' read -ra IPS <<< "$SNOWBALL_IPS"
    local connectivity_ok=true
    
    for ip in "${IPS[@]}"; do
        ip=$(echo "$ip" | xargs)
        log_info "Testing connectivity to $ip:8443..."
        
        if timeout 10 nc -z "$ip" 8443 2>/dev/null; then
            log_success "✅ $ip is reachable from this machine"
        else
            log_warning "❌ $ip is NOT reachable from this machine"
            connectivity_ok=false
        fi
    done
    
    if [[ "$connectivity_ok" == "false" ]]; then
        log_warning "Some Snowball devices are not reachable from this machine"
        log_warning "The EC2 instance may have different network connectivity"
    fi
    
    # Check if metrics are being sent
    log_info "Waiting for monitoring script to start sending metrics to CloudWatch..."
    log_info "(This may take 5-7 minutes as the instance completes setup and runs the first monitoring cycle)"
    sleep 300  # Give more time for user data script to complete and first monitoring run
    
    local metrics_found=false
    for i in {1..6}; do
        log_info "Checking for metrics (attempt $i/6)..."
        
        local metrics=$(aws cloudwatch list-metrics --region "$AWS_REGION" --namespace "Snowball/MultiDevice" --output json 2>/dev/null)
        local metric_count=$(echo "$metrics" | jq '.Metrics | length' 2>/dev/null || echo "0")
        
        if [[ $metric_count -gt 0 ]]; then
            log_success "Found $metric_count metrics in CloudWatch"
            metrics_found=true
            
            # Show the metrics we found
            echo "Metrics found:"
            echo "$metrics" | jq -r '.Metrics[] | "  - \(.MetricName) (Namespace: \(.Namespace))"' 2>/dev/null || echo "  (Could not parse metric details)"
            break
        else
            log_info "No metrics found yet, waiting 30 seconds..."
            sleep 30
        fi
    done
    
    if [[ "$metrics_found" == "false" ]]; then
        log_warning "No metrics found in CloudWatch yet"
        log_warning "This might indicate:"
        echo "  - User data script still running (check /var/log/cloud-init-output.log)"
        echo "  - Network connectivity issues from the instance"
        echo "  - Snowball devices not reachable from the instance"
        echo "  - IAM permissions issues"
        echo ""
        log_info "To troubleshoot:"
        if [[ -n "$SSH_KEY_NAME" ]] && [[ "$INSTANCE_PUBLIC_IP" != "none" ]]; then
            echo "  1. SSH to the instance: ssh -i $SSH_KEY_PATH ec2-user@$INSTANCE_PUBLIC_IP"
        fi
        echo "  1. Use Session Manager to connect to the instance"
        echo "  2. Check: sudo cat /var/log/cloud-init-output.log"
        echo "  3. Check: sudo cat /opt/snowball-monitor/setup-complete.txt"
        echo "  4. Check: sudo -u snowball-monitor /opt/snowball-monitor/snowball-monitor.sh"
    fi
    
    # Test SNS topic
    log_info "Testing SNS topic..."
    local test_message="🧪 Test message from Snowball Monitor deployment at $(date)"
    
    if aws sns publish --topic-arn "$SNS_TOPIC_ARN" --message "$test_message" --region "$AWS_REGION" --output text &>/dev/null; then
        log_success "Test SNS message sent successfully"
        log_info "Check your email for the test message"
    else
        log_warning "Failed to send test SNS message"
    fi
}

# ===============================================
# CLEANUP AND TEARDOWN
# ===============================================

show_cleanup_instructions() {
    log_step "Cleanup Instructions"
    
    echo "To remove all deployed resources, run these commands:"
    echo ""
    echo "# Stop and terminate EC2 instance"
    echo "aws ec2 terminate-instances --instance-ids $INSTANCE_ID --region $AWS_REGION"
    echo ""
    echo "# Delete CloudWatch alarms"
    echo "aws cloudwatch delete-alarms --alarm-names Snowball-MultiDevice-AnyOffline Snowball-MultiDevice-Monitor-NotReporting --region $AWS_REGION"
    echo ""
    echo "# Delete SNS topic"
    echo "aws sns delete-topic --topic-arn $SNS_TOPIC_ARN --region $AWS_REGION"
    echo ""
    echo "# Remove IAM resources"
    echo "aws iam remove-role-from-instance-profile --instance-profile-name $INSTANCE_PROFILE_NAME --role-name $IAM_ROLE_NAME"
    echo "aws iam delete-instance-profile --instance-profile-name $INSTANCE_PROFILE_NAME"
    echo "aws iam detach-role-policy --role-name $IAM_ROLE_NAME --policy-arn arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/$IAM_POLICY_NAME"
    echo "aws iam delete-role --role-name $IAM_ROLE_NAME"
    echo "aws iam delete-policy --policy-arn arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/$IAM_POLICY_NAME"
    echo ""
    echo "# Delete security group"
    echo "aws ec2 delete-security-group --group-id $SECURITY_GROUP_ID --region $AWS_REGION"
    echo ""
    echo "# Remove local configuration files"
    echo "rm -f $CONFIG_FILE $STATE_FILE"
}

# ===============================================
# MAIN SCRIPT EXECUTION
# ===============================================

show_banner() {
    echo ""
    echo "🔧 AWS Snowball Monitor - Automated Deployment"
    echo "==============================================="
    echo "Version: $SCRIPT_VERSION"
    echo "This script will deploy a complete Snowball monitoring solution with public IP"
    echo "Includes: Complete monitoring script, cron job, and CloudWatch integration"
    echo ""
}

show_summary() {
    log_step "Deployment Summary"
    
    echo "✅ Deployment completed successfully!"
    echo ""
    echo "📋 Resources Created:"
    echo "  • SNS Topic: $SNS_TOPIC_ARN"
    echo "  • IAM Role: $IAM_ROLE_NAME"
    echo "  • IAM Policy: $IAM_POLICY_NAME"
    echo "  • Instance Profile: $INSTANCE_PROFILE_NAME"
    echo "  • Security Group: $SECURITY_GROUP_ID"
    echo "  • EC2 Instance: $INSTANCE_ID (with public IP)"
    echo "  • CloudWatch Alarms: Snowball-MultiDevice-AnyOffline, Snowball-MultiDevice-Monitor-NotReporting"
    echo ""
    echo "📊 Monitoring Details:"
    local device_count=$(count_snowball_devices)
    echo "  • Monitoring $device_count Snowball devices"
    echo "  • Check frequency: Every $MONITORING_FREQUENCY minutes"
    echo "  • Alerts sent to: $ALERT_EMAIL"
    echo ""
    echo "🔍 Next Steps:"
    echo "  1. Check your email and confirm the SNS subscription"
    echo "  2. Monitor CloudWatch metrics in the 'Snowball/MultiDevice' namespace"
    echo "  3. Verify setup completed successfully using Session Manager or SSH"
    echo "  4. View logs and troubleshoot using the commands below"
    echo ""
    echo "📈 CloudWatch Dashboard:"
    echo "  https://console.aws.amazon.com/cloudwatch/home?region=$AWS_REGION#metricsV2:graph=~();query=Snowball%252FMultiDevice"
    echo ""
    echo "💰 Estimated Monthly Cost: ~$5-8 USD"
    echo ""
    
    echo "🔧 Instance Access:"
    echo "  Instance ID: $INSTANCE_ID"
    echo "  Private IP: $INSTANCE_PRIVATE_IP"
    echo "  Public IP: $INSTANCE_PUBLIC_IP"
    echo ""
    echo "  Session Manager: https://console.aws.amazon.com/systems-manager/session-manager/start-session?region=$AWS_REGION"
    echo "  (Select instance: $INSTANCE_ID)"
    echo ""
    
    if [[ -n "$SSH_KEY_NAME" ]] && [[ "$INSTANCE_PUBLIC_IP" != "none" ]]; then
        echo "  SSH Access:"
        echo "    ssh -i $SSH_KEY_PATH ec2-user@$INSTANCE_PUBLIC_IP"
        echo ""
    fi
    
    echo "  Useful commands once connected:"
    echo "    sudo cat /var/log/user-data.log                                    # View setup log"
    echo "    sudo cat /opt/snowball-monitor/setup-complete.txt                  # Check setup status"
    echo "    sudo -u snowball-monitor crontab -l                               # Check cron job"
    echo "    sudo tail -f /opt/snowball-monitor/logs/monitor-\$(date +%Y%m%d).log  # View live monitoring logs"
    echo "    sudo -u snowball-monitor /opt/snowball-monitor/snowball-monitor.sh # Test script manually"
    echo ""
}

main() {
    show_banner
    
    # Check if this is a cleanup request
    if [[ "$1" == "--cleanup" ]] || [[ "$1" == "--teardown" ]]; then
        show_cleanup_instructions
        exit 0
    fi
    
    # Main deployment process
    check_prerequisites
    configure_deployment
    
    echo ""
    log_info "Starting deployment with configuration:"
    echo "  Snowball IPs: $SNOWBALL_IPS"
    echo "  Alert Email: $ALERT_EMAIL"
    echo "  AWS Region: $AWS_REGION"
    echo "  VPC: $VPC_ID"
    echo "  Subnet: $SUBNET_ID"
    echo "  Instance Type: $INSTANCE_TYPE"
    echo "  Monitoring Frequency: Every $MONITORING_FREQUENCY minutes"
    echo "  SSH Access: ${SSH_KEY_NAME:-"None (Session Manager only)"}"
    echo "  User IP: ${USER_IP:-"N/A"}"
    echo "  Bastion SG: ${BASTION_SG_ID:-"None"}"
    echo "  Public IP: Always assigned"
    echo ""
    
    if [[ $(prompt_yes_no "Proceed with deployment?") == "n" ]]; then
        log_info "Deployment cancelled by user"
        exit 0
    fi
    
    deploy_infrastructure
    deploy_monitoring_script
    validate_deployment
    show_summary
    
    echo ""
    log_success "🎉 Snowball Monitor deployment completed successfully!"
    echo ""
    echo "Configuration saved to: $CONFIG_FILE"
    echo "Run this script again to update the configuration or redeploy."
    echo "Run './deploy-snowball-monitor.sh --cleanup' to see cleanup instructions."
}

# Handle script arguments
case "${1:-}" in
    --help|-h)
        echo "Usage: $0 [--cleanup|--teardown|--help]"
        echo ""
        echo "Options:"
        echo "  --cleanup, --teardown  Show cleanup instructions"
        echo "  --help, -h            Show this help message"
        echo ""
        echo "Run without arguments to start the deployment process."
        exit 0
        ;;
    --cleanup|--teardown)
        show_cleanup_instructions
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac